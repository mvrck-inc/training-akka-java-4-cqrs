第2回トレーニングで紹介したイベント・ソーシング設計パターンは永続仮想への書き込みパフォーマンスを維持しつつ、
耐障害性、アプリケーション層と永続化層の疎結合、履歴の保持によるトラブルシューティングの容易性などを実現しました。
しかし、データの書き込み側を設計するイベント・ソーシングだけでは不便なこともあります。それはデータ読み込み側の処理です。

ここでまた伝統的な3層アーキテクチャと対比して考えましょう。このアーキテクチャではアプリケーション層をステートレスに保つため、状態をデータベースに全て退避するのでした。
データベースは書き込み時に最新の状態をテーブルに常に保持するので、データ読込処理はこれらのテーブルから抽出・集計できます。
3層アーキテクチャでよく利用されるリレーショナル・データベースのSELECT文はまさにこの用途に適しています。

一方イベント・ソーシング「だけ」を採用したアプリケーションでは、永続化層はイベント履歴のみを保存するので、
データの最新状態を永続化層のデータベースだけで取得することは出来ません。
データの最新状態を読み込むにはアクターにメッセージを投げ、アクターが最新状態を含むメッセージを投げ返す必要があります。
これでは抽出や集計の際に困ってしまいます。データベースと違い、アクターは大量のデータから抽出、集計するのに向いていないからです。

- TODO: 抽出・集計の対比図

この問題への対処法は書き込み側はイベント・ソーシングを、読み込み側は別の設計を用いることです。
書き込み側(Command)と読み込み側(Read)に別々の設計パターンを用いると、CQRS - Command Query Responsibility Separationと呼ばれるパターンを実現できます。

- TODO: CQRSとイベント・ソーシング包有関係

CQRSが書き込み側と読み込み側を疎結合にすることで生まれるメリットは、以下のMicrosoftの記事がよくまとめているので引用します。

https://docs.microsoft.com/ja-jp/azure/architecture/patterns/cqrs
> - 読み取りと書き込みのワークロードが不均衡になりやすいため、パフォーマンスやスケールの要件が大きく異なってくる可能性があります。
> - 読み取りと書き込みのデータ表現が一致しないことがよくあります。具体的には、操作の一部としては必要ないものの、正しく更新しなければならない追加の列やプロパティなどです。

CQRSは大掛かりな設計パターンです。実装や運用の難易度が高いので、CRUDで十分な単純なシステムに適用するには向いていません。
あなたが作るシステムにCQRSが必要化は慎重に見極めてください。
また

